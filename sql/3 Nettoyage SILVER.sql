----------------------------------
--cleaning sur Silver
----------------------------------

USE SCHEMA SILVER;


-- FINANCIAL_TRANSACTIONS_CLEAN

CREATE OR REPLACE TABLE FINANCIAL_TRANSACTIONS_CLEAN AS
SELECT 
    TRANSACTION_ID,
    TRANSACTION_DATE,
    TRANSACTION_TYPE,
    -- Montants positifs uniquement
    ABS(AMOUNT) AS AMOUNT,
    PAYMENT_METHOD,
    ENTITY,
    REGION,
    ACCOUNT_CODE
FROM BRONZE.FINANCIAL_TRANSACTIONS
WHERE 
    -- Suppression des valeurs nulles critiques
    TRANSACTION_ID IS NOT NULL 
    AND TRANSACTION_DATE IS NOT NULL
    AND AMOUNT IS NOT NULL
    AND AMOUNT != 0
    -- Dédoublonnage : on garde la première occurrence par ID
QUALIFY ROW_NUMBER() OVER (PARTITION BY TRANSACTION_ID ORDER BY TRANSACTION_DATE) = 1;


--select count(*) from FINANCIAL_TRANSACTIONS_CLEAN;


-- 2. PROMOTIONS_CLEAN
CREATE OR REPLACE TABLE PROMOTIONS_CLEAN AS
SELECT 
    PROMOTION_ID,
    PRODUCT_CATEGORY,
    PROMOTION_TYPE,
    -- Pourcentage entre 0 et 100
    CASE 
        WHEN DISCOUNT_PERCENTAGE < 0 THEN 0
        WHEN DISCOUNT_PERCENTAGE > 100 THEN 100
        ELSE DISCOUNT_PERCENTAGE
    END AS DISCOUNT_PERCENTAGE,
    START_DATE,
    END_DATE,
    REGION,
    -- Calcul de la durée de la promotion
    DATEDIFF(day, START_DATE, END_DATE) AS PROMOTION_DURATION_DAYS
FROM BRONZE.PROMOTIONS_DATA
WHERE 
    PROMOTION_ID IS NOT NULL
    AND START_DATE IS NOT NULL
    AND END_DATE IS NOT NULL
    -- Vérification que la date de fin est après la date de début
    AND END_DATE >= START_DATE
QUALIFY ROW_NUMBER() OVER (PARTITION BY PROMOTION_ID ORDER BY START_DATE) = 1;

-- 3. MARKETING_CAMPAIGNS_CLEAN
CREATE OR REPLACE TABLE MARKETING_CAMPAIGNS_CLEAN AS
SELECT 
    CAMPAIGN_ID,
    CAMPAIGN_NAME,
    CAMPAIGN_TYPE,
    PRODUCT_CATEGORY,
    TARGET_AUDIENCE,
    START_DATE,
    END_DATE,
    REGION,
    -- Budget positif uniquement
    ABS(BUDGET) AS BUDGET,
    -- Reach positif uniquement
    CASE WHEN REACH < 0 THEN 0 ELSE REACH END AS REACH,
    -- Taux de conversion entre 0 et 100
    CASE 
        WHEN CONVERSION_RATE < 0 THEN 0
        WHEN CONVERSION_RATE > 100 THEN 100
        ELSE CONVERSION_RATE
    END AS CONVERSION_RATE,
    -- Métriques calculées
    DATEDIFF(day, START_DATE, END_DATE) AS CAMPAIGN_DURATION_DAYS,
    CASE 
        WHEN REACH > 0 THEN BUDGET / REACH 
        ELSE NULL 
    END AS COST_PER_REACH
FROM BRONZE.MARKETING_CAMPAIGNS
WHERE 
    CAMPAIGN_ID IS NOT NULL
    AND START_DATE IS NOT NULL
    AND END_DATE >= START_DATE
QUALIFY ROW_NUMBER() OVER (PARTITION BY CAMPAIGN_ID ORDER BY START_DATE DESC) = 1;

-- 4. LOGISTICS_AND_SHIPPING_CLEAN
CREATE OR REPLACE TABLE LOGISTICS_AND_SHIPPING_CLEAN AS
SELECT 
    SHIPMENT_ID,
    ORDER_ID,
    SHIP_DATE,
    ESTIMATED_DELIVERY,
    SHIPPING_METHOD,
    -- Normalisation du statut
    UPPER(TRIM(STATUS)) AS STATUS,
    -- Coût positif uniquement
    ABS(SHIPPING_COST) AS SHIPPING_COST,
    DESTINATION_REGION,
    DESTINATION_COUNTRY,
    CARRIER,
    -- Calcul du délai de livraison estimé
    DATEDIFF(day, SHIP_DATE, ESTIMATED_DELIVERY) AS ESTIMATED_DELIVERY_DAYS,
    -- Flag pour livraison tardive (si date d'expédition > date estimée)
    CASE 
        WHEN SHIP_DATE > ESTIMATED_DELIVERY THEN TRUE 
        ELSE FALSE 
    END AS IS_DELAYED
FROM BRONZE.LOGISTICS_AND_SHIPPING
WHERE 
    SHIPMENT_ID IS NOT NULL
    AND ORDER_ID IS NOT NULL
    AND SHIP_DATE IS NOT NULL
QUALIFY ROW_NUMBER() OVER (PARTITION BY SHIPMENT_ID ORDER BY SHIP_DATE DESC) = 1;

-- 5. SUPPLIER_INFORMATION_CLEAN
CREATE OR REPLACE TABLE SUPPLIER_INFORMATION_CLEAN AS
SELECT 
    SUPPLIER_ID,
    TRIM(SUPPLIER_NAME) AS SUPPLIER_NAME,
    PRODUCT_CATEGORY,
    REGION,
    COUNTRY,
    CITY,
    -- Lead time positif
    CASE WHEN LEAD_TIME < 0 THEN 0 ELSE LEAD_TIME END AS LEAD_TIME,
    -- Score de fiabilité entre 0 et 1
    CASE 
        WHEN RELIABILITY_SCORE < 0 THEN 0
        WHEN RELIABILITY_SCORE > 1 THEN 1
        ELSE RELIABILITY_SCORE
    END AS RELIABILITY_SCORE,
    UPPER(TRIM(QUALITY_RATING)) AS QUALITY_RATING
FROM BRONZE.SUPPLIER_INFORMATION
WHERE 
    SUPPLIER_ID IS NOT NULL
    AND SUPPLIER_NAME IS NOT NULL
QUALIFY ROW_NUMBER() OVER (PARTITION BY SUPPLIER_ID ORDER BY RELIABILITY_SCORE DESC) = 1;

-- 6. EMPLOYEE_RECORDS_CLEAN
CREATE OR REPLACE TABLE EMPLOYEE_RECORDS_CLEAN AS
SELECT 
    EMPLOYEE_ID,
    TRIM(NAME) AS NAME,
    DATE_OF_BIRTH,
    HIRE_DATE,
    TRIM(DEPARTMENT) AS DEPARTMENT,
    TRIM(JOB_TITLE) AS JOB_TITLE,
    -- Salaire positif uniquement
    ABS(SALARY) AS SALARY,
    REGION,
    COUNTRY,
    LOWER(TRIM(EMAIL)) AS EMAIL,
    -- Calcul de l'âge
    DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) AS AGE,
    -- Calcul de l'ancienneté
    DATEDIFF(year, HIRE_DATE, CURRENT_DATE()) AS YEARS_OF_SERVICE
FROM BRONZE.EMPLOYEE_RECORDS
WHERE 
    EMPLOYEE_ID IS NOT NULL
    AND NAME IS NOT NULL
    AND DATE_OF_BIRTH IS NOT NULL
    AND HIRE_DATE IS NOT NULL
    -- Vérifications de cohérence
    AND DATE_OF_BIRTH < HIRE_DATE
    AND HIRE_DATE <= CURRENT_DATE()
QUALIFY ROW_NUMBER() OVER (PARTITION BY EMPLOYEE_ID ORDER BY HIRE_DATE DESC) = 1;

-- 7. CUSTOMER_DEMOGRAPHICS_CLEAN
CREATE OR REPLACE TABLE CUSTOMER_DEMOGRAPHICS_CLEAN AS
SELECT 
    CUSTOMER_ID,
    TRIM(NAME) AS NAME,
    DATE_OF_BIRTH,
    UPPER(TRIM(GENDER)) AS GENDER,
    REGION,
    COUNTRY,
    CITY,
    UPPER(TRIM(MARITAL_STATUS)) AS MARITAL_STATUS,
    -- Revenu positif uniquement
    CASE WHEN ANNUAL_INCOME < 0 THEN 0 ELSE ANNUAL_INCOME END AS ANNUAL_INCOME,
    -- Calcul de l'âge
    DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) AS AGE,
    -- Segmentation par âge
    CASE 
        WHEN DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) < 18 THEN 'Minor'
        WHEN DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) BETWEEN 18 AND 25 THEN '18-25'
        WHEN DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) BETWEEN 26 AND 35 THEN '26-35'
        WHEN DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) BETWEEN 36 AND 50 THEN '36-50'
        WHEN DATEDIFF(year, DATE_OF_BIRTH, CURRENT_DATE()) BETWEEN 51 AND 65 THEN '51-65'
        ELSE '65+'
    END AS AGE_GROUP
FROM BRONZE.CUSTOMER_DEMOGRAPHICS
WHERE 
    CUSTOMER_ID IS NOT NULL
    AND DATE_OF_BIRTH IS NOT NULL
    AND DATE_OF_BIRTH < CURRENT_DATE()
QUALIFY ROW_NUMBER() OVER (PARTITION BY CUSTOMER_ID ORDER BY DATE_OF_BIRTH) = 1;

-- 8. CUSTOMER_SERVICE_INTERACTIONS_CLEAN
CREATE OR REPLACE TABLE CUSTOMER_SERVICE_INTERACTIONS_CLEAN AS
SELECT 
    INTERACTION_ID,
    INTERACTION_DATE,
    UPPER(TRIM(INTERACTION_TYPE)) AS INTERACTION_TYPE,
    UPPER(TRIM(ISSUE_CATEGORY)) AS ISSUE_CATEGORY,
    TRIM(DESCRIPTION) AS DESCRIPTION,
    -- Durée positive uniquement
    CASE WHEN DURATION_MINUTES < 0 THEN 0 ELSE DURATION_MINUTES END AS DURATION_MINUTES,
    UPPER(TRIM(RESOLUTION_STATUS)) AS RESOLUTION_STATUS,
    FOLLOW_UP_REQUIRED,
    -- Score de satisfaction entre 0 et 5
    CASE 
        WHEN CUSTOMER_SATISFACTION < 0 THEN 0
        WHEN CUSTOMER_SATISFACTION > 5 THEN 5
        ELSE CUSTOMER_SATISFACTION
    END AS CUSTOMER_SATISFACTION,
    -- Catégorisation de la satisfaction
    CASE 
        WHEN CUSTOMER_SATISFACTION >= 4 THEN 'Satisfied'
        WHEN CUSTOMER_SATISFACTION >= 3 THEN 'Neutral'
        ELSE 'Unsatisfied'
    END AS SATISFACTION_CATEGORY
FROM BRONZE.CUSTOMER_SERVICE_INTERACTIONS
WHERE 
    INTERACTION_ID IS NOT NULL
    AND INTERACTION_DATE IS NOT NULL
QUALIFY ROW_NUMBER() OVER (PARTITION BY INTERACTION_ID ORDER BY INTERACTION_DATE DESC) = 1;

-- 9. INVENTORY_CLEAN
CREATE OR REPLACE TABLE INVENTORY_CLEAN AS
SELECT 
    PRODUCT_ID,
    PRODUCT_CATEGORY,
    REGION,
    COUNTRY,
    WAREHOUSE,
    -- Stock positif ou 0
    CASE WHEN CURRENT_STOCK < 0 THEN 0 ELSE CURRENT_STOCK END AS CURRENT_STOCK,
    CASE WHEN REORDER_POINT < 0 THEN 0 ELSE REORDER_POINT END AS REORDER_POINT,
    CASE WHEN LEAD_TIME < 0 THEN 0 ELSE LEAD_TIME END AS LEAD_TIME,
    LAST_RESTOCK_DATE,
    -- Flag de réapprovisionnement nécessaire
    CASE 
        WHEN CURRENT_STOCK <= REORDER_POINT THEN TRUE 
        ELSE FALSE 
    END AS NEEDS_REORDER,
    -- Jours depuis le dernier réapprovisionnement
    DATEDIFF(day, LAST_RESTOCK_DATE, CURRENT_DATE()) AS DAYS_SINCE_RESTOCK
FROM BRONZE.INVENTORY
WHERE 
    PRODUCT_ID IS NOT NULL
    AND WAREHOUSE IS NOT NULL
    AND LAST_RESTOCK_DATE <= CURRENT_DATE()
QUALIFY ROW_NUMBER() OVER (PARTITION BY PRODUCT_ID, WAREHOUSE ORDER BY LAST_RESTOCK_DATE DESC) = 1;

-- 10. STORE_LOCATIONS_CLEAN
CREATE OR REPLACE TABLE STORE_LOCATIONS_CLEAN AS
SELECT 
    STORE_ID,
    TRIM(STORE_NAME) AS STORE_NAME,
    UPPER(TRIM(STORE_TYPE)) AS STORE_TYPE,
    REGION,
    COUNTRY,
    CITY,
    TRIM(ADDRESS) AS ADDRESS,
    POSTAL_CODE,
    -- Surface positive uniquement
    CASE WHEN SQUARE_FOOTAGE < 0 THEN NULL ELSE SQUARE_FOOTAGE END AS SQUARE_FOOTAGE,
    -- Nombre d'employés positif uniquement
    CASE WHEN EMPLOYEE_COUNT < 0 THEN 0 ELSE EMPLOYEE_COUNT END AS EMPLOYEE_COUNT,
    -- Surface par employé
    CASE 
        WHEN EMPLOYEE_COUNT > 0 THEN SQUARE_FOOTAGE / EMPLOYEE_COUNT 
        ELSE NULL 
    END AS SQUARE_FOOTAGE_PER_EMPLOYEE
FROM BRONZE.STORE_LOCATIONS
WHERE 
    STORE_ID IS NOT NULL
    AND STORE_NAME IS NOT NULL
QUALIFY ROW_NUMBER() OVER (PARTITION BY STORE_ID ORDER BY STORE_NAME) = 1;

-- 11. PRODUCT_REVIEWS_CLEAN
CREATE OR REPLACE TABLE PRODUCT_REVIEWS_CLEAN AS
SELECT 
    REVIEW_ID,
    PRODUCT_ID,
    REVIEWER_ID,
    TRIM(REVIEWER_NAME) AS REVIEWER_NAME,
    HELPFUL_VOTES,
    TOTAL_VOTES,
    -- Rating entre 1 et 5
    CASE 
        WHEN RATING < 1 THEN 1
        WHEN RATING > 5 THEN 5
        ELSE RATING
    END AS RATING,
    REVIEW_DATETIME,
    DATE(REVIEW_DATETIME) AS REVIEW_DATE,
    TRIM(REVIEW_TITLE) AS REVIEW_TITLE,
    TRIM(REVIEW_TEXT) AS REVIEW_TEXT,
    PRODUCT_CATEGORY_2 AS PRODUCT_CATEGORY,
    -- Calcul du taux d'utilité
    CASE 
        WHEN TOTAL_VOTES > 0 THEN (HELPFUL_VOTES::FLOAT / TOTAL_VOTES) * 100
        ELSE NULL
    END AS HELPFULNESS_PERCENTAGE,
    -- Catégorisation du rating
    CASE 
        WHEN RATING >= 4 THEN 'Positive'
        WHEN RATING = 3 THEN 'Neutral'
        ELSE 'Negative'
    END AS REVIEW_SENTIMENT
FROM BRONZE.PRODUCT_REVIEWS
WHERE 
    REVIEW_ID IS NOT NULL
    AND PRODUCT_ID IS NOT NULL
    AND REVIEW_DATETIME IS NOT NULL
QUALIFY ROW_NUMBER() OVER (PARTITION BY REVIEW_ID ORDER BY REVIEW_DATETIME DESC) = 1;

-- VÉRIFICATIONS DE QUALITÉ

-- Comptage des enregistrements par table
SELECT 'FINANCIAL_TRANSACTIONS_CLEAN' AS TABLE_NAME, COUNT(*) AS ROW_COUNT FROM FINANCIAL_TRANSACTIONS_CLEAN
UNION ALL
SELECT 'PROMOTIONS_CLEAN', COUNT(*) FROM PROMOTIONS_CLEAN
UNION ALL
SELECT 'MARKETING_CAMPAIGNS_CLEAN', COUNT(*) FROM MARKETING_CAMPAIGNS_CLEAN
UNION ALL
SELECT 'LOGISTICS_AND_SHIPPING_CLEAN', COUNT(*) FROM LOGISTICS_AND_SHIPPING_CLEAN
UNION ALL
SELECT 'SUPPLIER_INFORMATION_CLEAN', COUNT(*) FROM SUPPLIER_INFORMATION_CLEAN
UNION ALL
SELECT 'EMPLOYEE_RECORDS_CLEAN', COUNT(*) FROM EMPLOYEE_RECORDS_CLEAN
UNION ALL
SELECT 'CUSTOMER_DEMOGRAPHICS_CLEAN', COUNT(*) FROM CUSTOMER_DEMOGRAPHICS_CLEAN
UNION ALL
SELECT 'CUSTOMER_SERVICE_INTERACTIONS_CLEAN', COUNT(*) FROM CUSTOMER_SERVICE_INTERACTIONS_CLEAN
UNION ALL
SELECT 'INVENTORY_CLEAN', COUNT(*) FROM INVENTORY_CLEAN
UNION ALL
SELECT 'STORE_LOCATIONS_CLEAN', COUNT(*) FROM STORE_LOCATIONS_CLEAN
UNION ALL
SELECT 'PRODUCT_REVIEWS_CLEAN', COUNT(*) FROM PRODUCT_REVIEWS_CLEAN
ORDER BY TABLE_NAME;
